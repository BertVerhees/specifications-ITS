FORMAT: 1A
HOST: http://www.openehr.org/api



# OpenEHR REST API

OpenEHR REST API enables interaction with an OpenEHR service via the REST API.

In many places parameter `versionTime` is used. It is used to select a specific version
of a VERSIONED_OBJECT and can have the following values:
- `LATEST_TRUNK_VERSION`
- a specific timestamp in the full ISO8601 format (e.g. 2015-01-20T19:30:22.765+01:00)
- version uid

When parameter `versionTime` is not provided last version is returned (which is the same
as `versionTime=LATEST_TRUNK_VERSION`.


# Group EHR


## EHR [/ehr]

Management of EHRs.

### Create a new EHR [POST]

Request body may contain `ehr_status` and `ehr_access` attributes, if provided those
resources will also be created when EHR is created. If they are not provided defaults
will be created.

+ Request

    + Headers

            Prefer: return={representation/minimal}

    + Body

            {
                "commit_audit": {
                    "description": "Commit audit description",
                    "committer": {"@class": "PARTY_IDENTIFIED", ... }
                },
                "ehr_status": {},
                "ehr_access": {}
            }

+ Response 201 (application/json)

    New EHR has been created. Body is only returned when `Prefer` haeder
    has a value of `return=representation`

    + Headers

            Location: /ehr/{ehrId}

    + Body

            {
                "system_id": {},
                "ehr_id": {},
                "ehr_status": "versioned ehr status uid",
                "ehr_acess": "versioned ehr access uid",
                "directory": {},
                "time_created", "..."
            }

+ Response 400

    Unable to create a new EHR.

    + Body

+ Response 401

    Unauthorized.

    + Body


### Create a new EHR with supplied EHR id [PUT /ehr/{ehrId}]

Request body may contain `ehr_status` and `ehr_access` attributes, if provided those
resources will also be created when EHR is created. If they are not provided defaults
will be created.

+ Parameters
    + ehrId (string) - EHR id

+ Request

    + Headers

            Prefer: return={representation/minimal}

    + Body

            {
                "commit_audit": {
                    "description": "Commit audit description",
                    "committer": {"@class": "PARTY_IDENTIFIED", ... }
                },
                "ehr_status": {},
                "ehr_access": {}
            }

+ Response 201 (application/json)

    New EHR has been created. Body is only returned when `Prefer` haeder
    has a value of `return=representation`

    + Headers

            Location: /ehr/{ehrId}

    + Body

            {
                "system_id": {},
                "ehr_id": {},
                "ehr_status": "versioned ehr status uid",
                "ehr_acess": "versioned ehr access uid",
                "directory": {},
                "time_created", "..."
            }

+ Response 400

    Unable to create a new EHR. Can happen when the supplied ehrId already exists.

    + Body

+ Response 401

    Unauthorized.

    + Body


### Get an EHR [GET /ehr/{ehrId}]

+ Parameters
    + ehrId (string) - EHR id

+ Response 200 (application/json)

            {
                "system_id": {},
                "ehr_id": {},
                "ehr_status": "versioned ehr status uid",
                "ehr_acess": "versioned ehr access uid",
                "directory": {},
                "time_created", "...",
                ... // to be defined, possibly counts of compositions, contributions, etc.
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Delete an EHR [DELETE /ehr/{ehrId}]

_This call is under discussion._

+ Parameters
    + ehrId (string) - EHR id

+ Response 204

    EHR was deleted.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given EHR id.

    + Body


# Group EHR_STATUS

## EHR_STATUS [/ehr/{ehrId}/ehr_status]

### Get EHR_STATUS by versionUid [GET /ehr/{ehrId}/ehr_status/{versionUid}]

+ Parameters
    + ehrId (string) - EHR id
    + versionUid (string) - versionUid

+ Response 200 (application/json)

    + Body

            {
                "uid": "..",
                "subject": {},
                "is_queryable": true,
                "is_modifiable": true,
                "other_details": {}
            }


+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no VERSION with given versionUid.

    + Body

### Get EHR_STATUS [GET /ehr/{ehrId}/ehr_status{?versionTime}]

+ Parameters
    + ehrId (string) - EHR id
    + versionTime (string, optional) - version time specifier

+ Response 200 (application/json)

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_status/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "uid": "..",
                "subject": {},
                "is_queryable": true,
                "is_modifiable": true,
                "other_details": {}
            }


+ Response 204

    No version at versionTime.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body

### Update an EHR_STATUS [PUT /ehr/{ehrId}/ehr_status]

+ Parameters
    + ehrId (string) - EHR id

+ Request (application/json)

    + Header

            Match-If: {precedingVersionUid}
            Prefer: return={representation/minimal}

    + Body

            {
                "subject": {},
                "is_queryable": true,
                "is_modifiable": true,
                "other_details": {}
            }

+ Response 200

    Returned when `Prefer` header is set to `return=representation`.

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_status/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "uid": "...",
                "subject": {},
                "is_queryable": true,
                "is_modifiable": true,
                "other_details": {}
            }

+ Response 204

    Returned when `Prefer` header is NOT set to `return=representation`.

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_status/{versionUid}
            ETag: {versionUid}

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_status/{versionUid}
            ETag: {versionUid}

    + Body


## VERSIONED_EHR_STATUS [/ehr/{ehrId}/versioned_ehr_status]

### Get a VERSIONED_EHR_STATUS [GET /ehr/{ehrId}/versioned_ehr_status]

+ Parameters

    + ehrId (string) - EHR id

+ Response 200 (application/json)

    + Body

            {
                "uid": "xxx",
                "owner_id": "ehrId",
                "time_created": "ISO8601 timestamp",
                "version_count: 12,
                "all_version_ids": [
                    "versionedUid1",
                    "versionedUid2",
                    ...
                ]
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Get an EHR_STATUS version by versionUid [GET /ehr/{ehrId}/versioned_ehr_status/versions/{versionUid}]

Q: Should `/versions` be `/all_versions` to match RM?

+ Parameters

    + ehrId (string) - EHR id
    + versionUid (string) - versionUid

+ Response 200 (application/json)

    + Body

            {
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "uid": "...",
                "data": {
                    "subject": {},
                    "is_modifiable": "...",
                    "is_queryable": "...",
                    "other_details": {}
                }
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no version with versionUid.

    + Body


### Get an EHR_STATUS version [GET /ehr/{ehrId}/versioned_ehr_status/versions{?versionTime}]

+ Parameters

    + ehrId (string) - EHR id
    + versionTime (string, optional) - version time specifier

+ Response 200 (application/json)

    + Headers

            Content-Location: /ehr/{ehrId}/versioned_ehr_status/versions/{versionUid}

    + Body

            {
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "uid": "...",
                "data": {
                    "subject": {},
                    "is_modifiable": "...",
                    "is_queryable": "...",
                    "other_details": {}
                }
            }

+ Response 204

    No VERSION at specified versionTime.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Create a new EHR_STATUS version [POST /ehr/{ehrId}/versioned_ehr_status/version]

+ Parameters

    + ehrId (string) - EHR id

+ Request (application/json)

    + Headers

            Match-If: {precedingVersionUid}
            Prefer: return={representation/minimal}

    + Body

            {
                "commit_audit": {},
                "data": {
                    "subject": {},
                    "is_modifiable": "...",
                    "is_queryable": "...",
                    "other_details": {}
                }
            }

+ Response 201 (application/json)

    New EHR_STATUS version was created. Content body is only returned when
    `Prefer` header was set to `return=representation` otherwise only headers are
    returned.

    + Headers

            Location: /versioned_ehr_access/{uid}/versions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "uid": "...",
                "data": {
                    "subject": {},
                    "is_modifiable": "...",
                    "is_queryable": "...",
                    "other_details": {}
                }
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with given id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/versioned_ehr_status/versions/{versionUid}
            ETag: {versionUid}

    + Body



# Group EHR_ACCESS

## EHR_ACCESS [/ehr/{ehrId}/ehr_access]

### Get EHR_ACCESS by versionUid [GET /ehr/{ehrId}/ehr_access/{versionUid}]

+ Parameters
    + ehrId (string) - EHR id
    + versionUid (string) - versionUid

+ Response 200 (application/json)

    + Body

            {
                "uid": "...",
                "settings": {}
            }


+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no version with versionUid.

    + Body

### Get EHR_ACCESS [GET /ehr/{ehrId}/ehr_access{?versionTime}]

+ Parameters
    + ehrId (string) - EHR id
    + versionTime (string, optional) - version time specifier

+ Response 200 (application/json)

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_access/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "uid": "...",
                "settings": {}
            }


+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body

### Update an EHR_ACCESS [PUT /ehr/{ehrId}/ehr_access]

+ Parameters
    + ehrId (string) - EHR id

+ Request (application/json)

    + Header

            Match-If: {precedingVersionUid}
            Prefer: return={representation/minimal}

    + Body

            {
                "settings": {}
            }

+ Response 200

    Returned when `Prefer` header is set to `return=representation`.

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_status/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "uid": "...",
                "settings": {}
            }

+ Response 204

    Returned when `Prefer` header is NOT set to `return=representation`.

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_access/{versionUid}
            ETag: {versionUid}

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_access/{versionUid}
            ETag: {versionUid}

    + Body



## VERSIONED_EHR_ACCESS [/ehr/{ehrId}/versioned_ehr_access]

### Get a VERSIONED_EHR_ACCESS [GET /ehr/{ehrId}/versioned_ehr_access]

+ Parameters

    + ehrId (string) - EHR id

+ Response 200 (application/json)

    + Body

            {
                "uid": "xxx",
                "owner_id": "ehrId",
                "time_created": "ISO8601 timestamp",
                "version_count: 12,
                "all_version_ids": [
                    "versionedUid1",
                    "versionedUid2",
                    ...
                ]
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Get an EHR_ACCESS version by versionUid [GET /ehr/{ehrId}/versioned_ehr_access/versions/{versionUid}]

+ Parameters

    + ehrId (string) - EHR id
    + versionUid (string) - versionUid

+ Response 200 (application/json)

    + Body

            {
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "uid": "...",
                "data": {
                    "settings": {},
                }
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Get an EHR_ACCESS version [GET /ehr/{ehrId}/versioned_ehr_access/version{?versionTime}]

+ Parameters

    + ehrId (string) - EHR id
    + versionTime (string, optional) - version time specifier

+ Response 200 (application/json)

    + Body

            {
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "uid": "...",
                "data": {
                    "settings": {},
                }
            }

+ Response 204

    No VERSION at versionTime.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Create a new EHR_ACCESS version [POST /ehr/{ehrId}/versioned_ehr_access/version]

+ Parameters

    + ehrId (string) - EHR id

+ Request

    + Body (application/json)

            {
                "commit_audit": {},
                "data": {
                    "settings": {},
                }
            }

    + Headers

            Match-If: {precedingVersionUid}
            Prefer: return={representation/minimal}

+ Response 201 (application/json)

    New EHR_ACCESS version was created. Content body is only returned when
    `Prefer` header was set to `return=representation` otherwise only headers are
    returned.

    + Headers

            Location: /ehr/{ehrId}/versioned_ehr_access/versions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "uid": "...",
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "data": {
                    "subject": {},
                    "is_modifiable": "...",
                    "is_queryable": "...",
                    "other_details": {}
                }
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with given id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/versioned_ehr_access/versions/{versionUid}
            ETag: {versionUid}

    + Body



# Group DIRECTORY

## Directory [/ehr/{ehrId}/directory]

### Create a directory [POST /ehr/{ehrId}/directory]

+ Parameters

    + ehrId (string) - EHR id

+ Request

    + Body (application/json)

            {
                "items": [...],
                "folders": [{}]
            }

    + Headers

            Prefer: return={representation/minimal}

+ Response 201 (application/json)

    New directory was created. Content body is only returned when
    `Prefer` header has `return=representation` otherwise only headers are
    returned.

    + Headers

            Location: /ehr/{ehrId}/directory/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "uid": "...",
                "items": [...],
                "folders": [{}]
            }

+ Response 400

    Bad request - error creating a directory.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Update a directory [PUT /ehr/{ehrId}/directory]

+ Parameters

    + ehrId (string) - EHR id

+ Request

    + Body (application/json)

            {
                "items": [...],
                "folders": [{}]
            }

    + Headers

            Match-If: {precedingVersionUid}
            Prefer: return={representation/minimal}

+ Response 200 (application/json)

    Directory was updated.
    Returned when `Prefer` header is set to `return=representation`.

    + Headers

            Location: /ehr/{ehrId}/directory/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "uid": "...",
                "items": [...],
                "folders": [{}]
            }

+ Response 204

    Directory was updated.
    Returned when `Prefer` header is NOT set to `return=representation`.

    + Headers

            Location: /ehr/{ehrId}/directory/{versionUid}
            ETag: {versionUid}

+ Response 400

    Bad request - error when updating a directory.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/directory/{versionUid}
            ETag: {versionUid}

    + Body


### Delete a directory [DELETE /ehr/{ehrId}/directory]

+ Parameters

    + ehrId (string) - EHR id

+ Request

    + Headers

            Match-If: {precedingVersionUid}

+ Response 204

    Directory was deleted.

    + Body

+ Response 400

    Bad request - error deleting directory.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/directory/{versionUid}
            ETag: {versionUid}

    + Body

### Get a directory or its sub-folder by versionUid [GET /ehr/{ehrId}/directory/{versionUid}{?path}]

+ Parameters

    + ehrId (string) - EHR id
    + versionUid (string) - versionUid
    + path (string, optional) - path to a sub-folder

+ Response 200 (application/json)

    + Body

            {
                "uid": "...",
                "items": [...],
                "folders": [{}]
            }

+ Response 204

    No sub-folder at provided path.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no directory with specified versionUid.

    + Body


### Get a directory or its sub-folder [GET /ehr/{ehrId}/directory{?versionTime,path}]

+ Parameters

    + ehrId (string) - EHR id
    + versionTime (string, optional) - version time specifier
    + path (string, optional) - path to a sub-folder

+ Response 200 (application/json)

    + Headers

            Location: /ehr/{ehrId}/directory/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "uid": "...",
                "items": [...],
                "folders": [{}]
            }

+ Response 204

    EHR has no directory at versionTime or no sub-folder at provided path.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


# Group COMPOSITION

## Composition [/ehr/{ehrId}/compositions]

### Get a composition by version uid [GET /ehr/{ehrId}/compositions/{versionUid}{?format}]

+ Parameters

    + ehrId (string) - EHR id.
    + versionUid (string) - version uid
    + format (string, optional)...format of the composition (when ommitted canonical openEHR is assumed)

+ Response 200 (application/json)

    + Body

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR or no composition with the version uid.

    + Body

### Get a composition [GET /ehr/{ehrId}/compositions/{objectId}{?versionTime,format}]

+ Parameters

    + ehrId (string) - EHR id.
    + objectId (string) - VERSIONED_COMPOSITION's uid
    + versionTime (string, optional) - version time specifier
    + format (string, optional)...format of the composition (when ommitted canonical openEHR is assumed)

+ Response 200 (application/json)

    + Headers

            Content-Location: /ehr/{ehrId}/compositions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

+ Response 204 (application/json)

    No composition at specified versionTime.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR or no composition with the given object id.

    + Body


### Create a new composition [POST /ehr/{ehrId}/compositions{?format}]

+ Parameters

    + ehrId (string) - EHR id
    + format (string, optional)...format of the composition (when ommitted canonical openEHR is assumed)

+ Request

    + Body (application/json)

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

    + Headers

            Prefer: return={representation/minimal}

+ Response 201

    New composition was created. Content body is only returned when
    `Prefer` header has `return=representation` otherwise only headers are
    returned.

    + Headers

            Location: /ehr/{ehrId}/compositions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

+ Response 400

    Bad request: composition validation errors.

    + Body

            {
                "message": "Error message",
                "validationErrors": [
                    "error1", "error2"
                ]
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body

### Update or create a composition [PUT /ehr/{ehrId}/compositions/{objectId}{?format}]

This call can be used to update an existing composition (identified by {objectId}) or
to create a new one with the supplied {objectId} instead of a server assigned one.
In case of an update `Match-If` header _might_ be required.

+ Parameters

    + ehrId (string) - EHR id
    + objectId (string) - object id of the composition to update or create with this id
    + format (string, optional) - optional format of the composition (when ommitted canonical openEHR is assumed)

+ Request

    + Body (application/json)

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

    + Headers

            Match-If: {precedingVersionUid}
            Prefer: return={representation/minimal}

+ Response 200 (application/json)

    Returned when `Prefer` header is set to `return=representation`.

    + Headers

            Content-Location: /ehr/{ehrId}/compositions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

+ Response 204

    Returned when `Prefer` header is NOT set to `return=representation`.

    + Headers

            Content-Location: /ehr/{ehrId}/compositions/{versionUid}
            ETag: {versionUid}

+ Response 400

    Bad request: composition validation errors.

    + Body

            {
                "message": "Error message",
                "validationErrors": [
                    "error1", "error2"
                ]
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no composition with the given object id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_status/{versionUid}
            ETag: {versionUid}

    + Body

### Delete a composition [DELETE /ehr/{ehrId}/compositions/{objectId}]

+ Parameters

    + ehrId (string) - EHR id
    + objectId (string) - object id of the composition to delete

+ Request

    + Headers

            Match-If: {precedingVersionUid}

+ Response 204

    Composition was deleted.

    + Headers

            Content-Location: /ehr/{ehrId}/compositions/{versionUid}
            ETag: {versionUid}

    + Body

+ Response 400

    Bad request.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no composition with the given object id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/compositions/{versionUid}
            ETag: {versionUid}

    + Body

### Update a composition directly [PUT /compositions/{objectId}{?format}]

+ Parameters

    + objectId (string) - object id of the composition to update
    + format (string, optional) - optional format of the composition (when ommitted canonical openEHR is assumed)

+ Request

    + Body (application/json)

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

    + Headers

            Match-If: {precedingVersionUid}
            Prefer: return={representation/minimal}

+ Response 200 (application/json)

    Returned when `Prefer` header is set to `return=representation`.

    + Headers

            Content-Location: /ehr/{ehrId}/compositions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

+ Response 204

    Returned when `Prefer` header is NOT set to `return=representation`.

    + Headers

            Content-Location: /ehr/{ehrId}/compositions/{versionUid}
            ETag: {versionUid}

+ Response 400 (application/json)

    Bad request: composition validation errors.

    + Body

            {
                "message": "Error message",
                "validationErrors": [
                    "error1", "error2"
                ]
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no composition with the given object id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/ehr_status/{versionUid}
            ETag: {versionUid}

    + Body


### Delete a composition directly [DELETE /compositions/{objectId}]

+ Parameters

    + objectId (string) - object id of the composition to delete

+ Request

    + Headers

            Match-If: {precedingVersionUid}

+ Response 204

    Composition was deleted.

    + Headers

            Content-Location: /compositions/{versionUid}
            ETag: {versionUid}

    + Body

+ Response 400

    Bad request.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no composition with the given object id.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /compositions/{versionUid}
            ETag: {versionUid}

    + Body


### Get a composition by version uid directly [GET /compositions/{versionUid}{?format}]

+ Parameters

    + versionUid (string) - version uid
    + format (string, optional)...format of the composition (when ommitted canonical openEHR is assumed)

+ Response 200 (application/json)

    + Body

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No composition with the version uid.

    + Body

### Get a composition directly [GET /compositions/{objectId}{?versionTime,format}]

+ Parameters

    + objectId (string) - VERSIONED_COMPOSITION's uid
    + versionTime (string, optional) - version time specifier
    + format (string, optional)...format of the composition (when ommitted canonical openEHR is assumed)

+ Response 200 (application/json)

    + Headers

            Content-Location: /compositions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "@class": "COMPOSITION",
                "name": {
                    "@class": "DV_TEXT",
                    "value": "Vital Signs"
                },
                ...
            }

+ Response 204 (application/json)

    No composition at specified versionTime.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No composition with the given object id.

    + Body


## Versioned Composition [/ehr/{ehrId}/versioned_compositions]

### Create a new versioned composition [POST /ehr/{ehrId}/versioned_compositions]

+ Parameters

    + ehrId (string) - EHR id

+ Request

    + Headers

            Prefer: return={representation/minimal}

+ Response 201 (application/json)

    New versioned composition was created. Content body is only returned when
    `Prefer` header has `return=representation` otherwise only headers are
    returned.

    + Headers

            Location: /ehr/{ehrId}/versioned_compositions/{uid}

    + Body

            {
                "uid": "xxx",
                "owner_id": "ehrId",
                "time_created": "ISO8601 timestamp"
            }

+ Response 400

    Bad request - when VERSIONED_COMPOSITION with the given uid already exists.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Create a new versioned composition with supplied uid [PUT /ehr/{ehrId}/versioned_compositions/{uid}]

+ Parameters

    + ehrId (string) - EHR id
    + uid (string) - VERSIONED_COMPOSITION uid

+ Request

    + Headers

            Prefer: return={representation/minimal}

+ Response 201 (application/json)

    New versioned composition was created. Content body is only returned when
    `Prefer` header has `return=representation` otherwise only headers are
    returned.

    + Headers

            Location: /ehr/{ehrId}/versioned_compositions/{uid}

    + Body

            {
                "uid": "xxx",
                "owner_id": "ehrId",
                "time_created": "ISO8601 timestamp"
            }

+ Response 400

    Bad request - when VERSIONED_COMPOSITION with the given uid already exists.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Get a versioned composition [GET /ehr/{ehrId}/versioned_compositions/{uid}]

Gets a complete VERSIONED_COMPOSITION.

+ Parameters

    + ehrId (string) - EHR id
    + uid (string) - VERSIONED_COMPOSITION's uid

+ Response 200 (application/json)

    + Headers

            Location: /ehr/{ehrId}/versioned_compositions/{uid}

    + Body

            {
                "uid": "xxx",
                "owner_id": "ehrId",
                "time_created": "ISO8601 timestamp",
                "version_count: 12,
                "all_version_ids": [
                    "versionedUid1",
                    "versionedUid2",
                    ...
                ]
            }

+ Response 400

    Bad request - when VERSIONED_COMPOSITION with the given uid already exists.

    + Body

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id.

    + Body


### Create a new composition version [POST /ehr/{ehrId}/versioned_compositions/{uid}/version{?format}]

+ Parameters

    + ehrId (string) - EHR id
    + uid (string) - VERSIONED_COMPOSITION's uid
    + format (string, optional) - optional format of the composition (when ommitted canonical openEHR
    is assumed)

+ Request

    + Body (application/json)

            {
                "commit_audit": {},
                "data": {
                    "@class": "COMPOSITION",
                    "name": {
                        "@class": "DV_TEXT",
                        "value": "Vital Signs"
                    }
                    ...
                }
            }

    + Headers

            Match-If: {precedingVersionUid}
            Prefer: return={representation/minimal}

+ Response 201 (application/json)

    New composition version was created. Content body is only returned when
    `Prefer` header was set to `return=representation` otherwise only headers are
    returned.

    + Headers

            Location: /ehr/{ehrId}/versioned_compositions/{uid}/versions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "uid": "...",
                "data": {
                    "@class": "COMPOSITION",
                    "name": {
                        "@class": "DV_TEXT",
                        "value": "Vital Signs"
                    }
                    ...
                }
            }

+ Response 400

    Bad request: composition validation errors.

    + Body

            {
                "message": "Error message",
                "validationErrors": [
                    "error1", "error2"
                ]
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id or no VERSIONED_COMPOSITION with uid.

    + Body

+ Response 412

    `Match-If` header doesn't match the last version. Returns
    last version in the `Content-Location` and `ETag` headers.

    + Headers

            Content-Location: /ehr/{ehrId}/versioned_compositions/{uid}/versions/{versionUid}
            ETag: {versionUid}

    + Body

### Get a composition version by versionUid [GET /ehr/{ehrId}/versioned_compositions/{uid}/version/{versionUid}{?format}]

+ Parameters

    + ehrId (string) - EHR id
    + uid (string) - VERSIONED_COMPOSITION's uid
    + versionUid (string) - version uid
    + format (string, optional) - optional format of the composition (when ommitted canonical openEHR
    is assumed)

+ Response 200 (application/json)

    + Body

            {
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "uid": "...",
                "data": {
                    "@class": "COMPOSITION",
                    "name": {
                        "@class": "DV_TEXT",
                        "value": "Vital Signs"
                    }
                    ...
                }
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id, no VERSIONED_COMPOSITION with uid or no version with versionUid.

    + Body

### Get a composition version [GET /ehr/{ehrId}/versioned_compositions/{uid}/version{?versionTime,format}]

+ Parameters

    + ehrId (string) - EHR id
    + uid (string) - VERSIONED_COMPOSITION's uid
    + versionTime (string, optional) - version time specifier
    + format (string, optional) - optional format of the composition (when ommitted canonical openEHR is assumed)

+ Response 200 (application/json)

    + Headers

            Location: /ehr/{ehrId}/versioned_compositions/{uid}/versions/{versionUid}
            ETag: {versionUid}

    + Body

            {
                "contribution": {},
                "signature": "...",
                "commit_audit": {},
                "uid": "...",
                "data": {
                    "@class": "COMPOSITION",
                    "name": {
                        "@class": "DV_TEXT",
                        "value": "Vital Signs"
                    }
                    ...
                }
            }

+ Response 401

    Unauthorized.

    + Body

+ Response 404

    No EHR with the given id, no VERSIONED_COMPOSITION with uid or no version with versionUid.

    + Body

# Group QUERY

## Querying [/query]

### Get query results [POST /query/aql]

Execute an AQL query.

NOTE: we might add a header to indicate which EHR to execute against to
allow systems that need to route based of EHR id to do so without having
to analyze the request body.

+ Request (application/json)

    + Body

            {
                "aql": "SELECT ....",
                "aqlParameters": {
                    "parameter-name": "parameter-value",...
                },
                "offset": 999,
                "fetch": 888,
                // possibly more, TBD
            }

+ Response 200

        {
            "metaData": {
                "hits": 199,
                ...
            },
            "resultSet": [
                {
                    "unit": "°C",
                    "temperature": 38.8
                },
                {
                    "unit": "°C",
                    "temperature": 38.8
                },
                {
                    "unit": "°C",
                    "temperature": 38.8
                }
            ],
            "executedAql": "aql with replaced parameters",
        }
